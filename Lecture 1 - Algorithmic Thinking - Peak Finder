Review of Lecture 1 (Peak Finder, Insertion Sort, Merge Sort)
PEAK FINDER
One-Dimensional Case: 
[[a][b][c][d][e][f][g][h][i]]
  1  2  3  4  5  6  7  8  9

CONDITIONS:
a - i are numbers
Example #1: Position 2 is the peak iff b >= a and b >= c.
Example #2: Position 3 is the peak iff c >= b and c >= d. 
"Look to your left, then look to your right, see if you're equal"

FIRST WAY -- STRAIGHTFORWARD ALGORITHM
Start from the left [[1][2][n/2][n-1][n]]
                           /\
                          /  \  
                           This might be the peak. Look at n/2 element
                           Worst complexity here is Θn: Reasoning? "We are looking at all N elements"
something that a constant times n (Θn)
One way to make this faster? DIVIDE-AND-CONQUER!

Look at all n/2 positions...
  if a[n/2] < a[(n/2)-1] then look at the left hand 1...(n/2)-1 for a peak
  else if a[n/2] < a[(n/2)+1] then (n/2)+1 n for a peak
  else (n/2) position is a peak.
    (^Here, we argue that the algorithm is correct)
                           

